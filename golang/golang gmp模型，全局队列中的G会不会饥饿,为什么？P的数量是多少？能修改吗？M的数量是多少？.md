> **题目序号：**(165)
>
> **题目来源：**哔哩哔哩
> **频次：**1

**答案1：**（阿纪、）

1. 全局队列中的G不会饥饿。 因为线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。
   M运行G，G执行之后，M会从P获取下一个G，不断重复下去。所以全局队列中的G总是能被消费掉.

2. P的数量可以理解为最大为本机可执行的cpu的最大数量。
   通过runtime.GOMAXPROCS(runtime.NumCPU())设置。
   runtime.NumCPU()方法返回当前进程可用的逻辑cpu数量。

**答案2：**（趁醉独饮痛）

全局队列中的G不会饥饿，P中每执行61次调度，就需要优先从全局队列中获取一个G到当前P中，并执行下一个要执行的G。

调度协程的优先级与顺序：
![](https://image-1302243118.cos.ap-beijing.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220403162913.png)

P，可以通过 runtime.GOMAXPROCS() 设置数量，默认为当前CP

**M数量问题**
Go语⾔本身是限定M的最⼤量是10000。
runtime/debug包中的SetMaxThreads函数来设置。
有⼀个M阻塞，会创建⼀个新的M。
如果有M空闲，那么就会回收或者睡眠。



> **题目序号：**（423、3247）
> **题目来源：**腾讯
> **频次：**1

**答案1：**（趁醉独饮痛）

定义一个辅助数组保存key，对辅助数组进行排序，然后利用顺序输出