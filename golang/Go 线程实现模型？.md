Go实现的是两级线程模型（M：N)，准确的说是GMP模型，是对两级线程模型的改进实现，使它能够更加灵活地进行线程之间的调度。

### 背景

|                 | 含义                                                         | 缺点                                                     |
| --------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| 单进程时代      | 每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程 | 1. 无法并发，只能串行   2. 进程阻塞所带来的 CPU 时间浪费 |
| 多进程/线程时代 | 一个线程阻塞， cpu 可以立刻切换到其他线程中去执行            | 1. 进程/线程占用内存高  2. 进程/线程上下文切换成本高     |
| 协程时代        | 协程（用户态线程）绑定线程（内核态线程），cpu调度线程执行    | 1. 实现起来较复杂，协程和线程的绑定依赖调度器算法        |

线程 -> CPU 由 操作系统 调度，协程 -> 线程 由Go调度器来调度，协程与线程的映射关系有三种线程模型

### 三种线程模型

线程实现模型主要分为：`内核级线程模型`、`用户级线程模型`、`两级线程模型`，他们的区别在于用户线程与内核线程之间的对应关系。

**内核级线程模型（1：1）**

1个用户线程对应1个内核线程，这种最容易实现，协程的调度都由 CPU 完成了

![](https://image-1302243118.cos.ap-beijing.myqcloud.com/imgcdn/ult_klt_1_1.jpg)

优点：

- 实现起来最简单
- 能够利用多核
- 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行

缺点：

- 上下文切换成本高，创建、删除和切换都由 CPU 完成

**用户级线程模型（N：1）**

1个进程中的所有线程对应1个内核线程

![](https://image-1302243118.cos.ap-beijing.myqcloud.com/imgcdn/ult_klt_n_1.jpg)

优点：

- 上下文切换成本低，在用户态即可完成协程切换

缺点：

- 无法利用多核
- 一旦协程阻塞，造成线程阻塞，本线程的其它协程无法执行

**两级线程模型（M：N)**

M个线程对应N个内核线程

![](https://image-1302243118.cos.ap-beijing.myqcloud.com/imgcdn/ult_klt_n_m.jpg)

优点：

- 能够利用多核
- 上下文切换成本低
- 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行

缺点：

- 实现起来最复杂