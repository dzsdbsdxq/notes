> **题目序号：**261
>
> **题目来源**：  
>
> **频次**：1

 **答案1：**（趁醉独饮痛）

1. **Gosched()**：让当前线程让出 cpu 以让其它线程运行，它不会挂起当前线程，因此当前线程未来会继续执行。
2. **NumCPU()**：返回当前系统的 CPU 核数量。
3. **GOMAXPROCS()**：设置最大的可同时使用的 CPU 核数。
   通过runtime.GOMAXPROCS函数，应用程序可以设置运行时系统中的 P 最大数量。注意，如果在运行期间设置该值的话，会引起“Stop the World”。所以，应在应用程序最早期调用，并且最好是在运行Go程序之前设置好操作程序的环境变量GOMAXPROCS，而不是在程序中调用runtime.GOMAXPROCS函数。

无论我们传递给函数的整数值是什么值，运行时系统的P最大值总会在1~256之间。

go1.8 后，默认让程序运行在多个核上，可以不用设置了。

go1.8 前，还是要设置一下，可以更高效的利用 cpu。

4. Goexit()：退出当前 goroutine（但是defer语句会照常执行）。
5. **NumGoroutine**：返回正在执行和排队的任务总数。
   runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的 Goroutine 的数量。这里的特定状态是指GrunnableGruningGsyscallGwaition。处于这些状态的Groutine即被看做是活跃的或者说正在被调度。

注意：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。

6. **GOOS**：查看目标操作系统。很多时候，我们会根据平台的不同实现不同的操作，就可以用GOOS来查看自己所在的操作系统。
7. **runtime.GC**：会让运行时系统进行一次强制性的垃圾收集。
   强制的垃圾回收：不管怎样，都要进行的垃圾回收。非强制的垃圾回收：只会在一定条件下进行的垃圾回收（即运行时，系统自上次垃圾回收之后新申请的堆内存的单元（也成为单元增量）达到指定的数值）。
8. **GOROOT()**：获取 goroot 目录。
9. **runtime.LockOSThread 和 runtime.UnlockOSThread 函数**：前者调用会使调用他的 Goroutine 与当前运行它的M锁定到一起，后者调用会解除这样的锁定。