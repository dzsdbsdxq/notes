
在任何情况下，Go 运行时并行执行（注意，不是并发）的 goroutines 数量是 小于等于 P 的数量的。为了提高系统的性能，P 的数量肯定不是越小越好，所 以官方默认值就是 CPU 的核心数，设置的过小的话，如果一个持有 P 的 M， 由于 P 当前执行的 G 调用了 syscall 而导致 M 被阻塞，那么此时关键点： GO 的调度器是迟钝的，它很可能什么都没做，直到 M 阻塞了相当长时间以 后，才会发现有一个 P/M 被 syscall 阻塞了。然后，才会用空闲的 M 来强这 个 P。**通过 sysmon 监控实现的抢占式调度，**最快在 20us，最慢在 10-20ms 才 会发现有一个 M 持有 P 并阻塞了。操作系统在 1ms 内可以完成很多次线程调 度（一般情况 1ms 可以完成几十次线程调度），Go 发起 IO/syscall 的时候执 行该 G 的 M 会阻塞然后被 OS 调度走，P 什么也不干，sysmon 最慢要 10-20ms 才能发现这个阻塞，说不定那时候阻塞已经结束了，这样宝贵的 P 资源就这么 被阻塞的 M 浪费了。