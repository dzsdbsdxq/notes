>  **题目序号:**（3979,9，31，98，152，218，486，637，651，694，739，819，863，917，937，1216，1674，1865，2298，2708，3285，3303，3602，5117，5164，5443，5678，5654，6065，6370，6551、2360）
>
>  **题目来源：**深信服，百度，小米，哔哩哔哩，好未来，跟谁学，学而思，网易，腾讯，知乎，高德，字节，，新浪，虾皮，Aibee。
>
>  **频次：**32

**答案1：**（溪尾）

G是`Goroutine`的缩写，相当于操作系统的进程控制块(process control block)。它包含：函数执行的指令和参数，任务对象，线程上下文切换，字段保护，和字段的寄存器。

M是一个线程，每个M都有一个线程的栈。如果没有给线程的栈分配内存，操作系统会给线程的栈分配默认的内存。当线程的栈制定，M.stack->G.stack, M的PC寄存器会执行G提供的函数。

P(处理器，Processor)是一个抽象的概念，不是物理上的CPU。当一个P有任务，需要创建或者唤醒一个系统线程去处理它队列中的任务。P决定同时执行的任务的数量，`GOMAXPROCS`限制系统线程执行用户层面的任务的数量。

GO调度器的调度过程，首先创建一个G对象，然后G被保存在P的本地队列或者全局队列（global queue）。这时P会唤醒一个M。P按照它的执行顺序继续执行任务。M寻找一个空闲的P，如果找得到，将G与自己绑定。然后M执行一个调度循环：调用G对象->执行->清理线程->继续寻找Goroutine。

在M的执行过程中，上下文切换随时发生。当切换发生，任务的执行现场需要被保护，这样在下一次调度执行可以进行现场恢复。M的栈保存在G对象中，只有现场恢复需要的寄存器(SP,PC等)，需要被保存到G对象。

如果G对象还没有被执行，M可以将G重新放到P的调度队列，等待下一次的调度执行。当调度执行时，M可以通过G的vdsoSP, vdsoPC 寄存器进行现场恢复。

P队列 P有2种类型的队列：

2. 本地队列：本地的队列是无锁的，没有数据竞争问题，处理速度比较高。
2. 全局队列：是用来平衡不同的P的任务数量，所有的M共享P的全局队列。

线程清理 G的调度是为了实现P/M的绑定，所以线程清理就是释放P上的G，让其他的G能够被调度。

1. 主动释放(active release)：典型的例子是，执行G任务时，发生了系统调用(system call)，这时M会处于阻塞（Block）状态。调度器会设置一个超时时间，来释放P。
2. 被动释放(passive release)：如果系统调用发生，监控程序需要扫描处于阻塞状态的P/M。 这时，超时之后，P资源会回收，程序被安排给队列中的其他G任务。